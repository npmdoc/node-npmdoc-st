<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/isaacs/st#readme"

    >st (v1.2.0)</a>
</h1>
<h4>A module for serving static files.  Does etags, caching, etc.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.st">module st</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.st">
            function <span class="apidocSignatureSpan"></span>st
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount">
            function <span class="apidocSignatureSpan">st.</span>Mount
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">st.</span>Mount.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.st.Mount">module st.Mount</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.Mount">
            function <span class="apidocSignatureSpan">st.</span>Mount
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.st.Mount.prototype">module st.Mount.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype._loadContent">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>_loadContent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype._loadIndex">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>_loadIndex
            <span class="apidocSignatureSpan">(p, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype._loadReaddir">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>_loadReaddir
            <span class="apidocSignatureSpan">(p, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype._loadStat">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>_loadStat
            <span class="apidocSignatureSpan">(key, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype.autoindex">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>autoindex
            <span class="apidocSignatureSpan">(p, req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype.cachedFile">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>cachedFile
            <span class="apidocSignatureSpan">(p, stat, etag, req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype.error">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>error
            <span class="apidocSignatureSpan">(er, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype.file">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>file
            <span class="apidocSignatureSpan">(p, fd, stat, etag, req, res, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype.getCacheOptions">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>getCacheOptions
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype.getPath">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>getPath
            <span class="apidocSignatureSpan">(u)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype.getUrl">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>getUrl
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype.index">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>index
            <span class="apidocSignatureSpan">(p, req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype.serve">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>serve
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.st.Mount.prototype.streamFile">
            function <span class="apidocSignatureSpan">st.Mount.prototype.</span>streamFile
            <span class="apidocSignatureSpan">(p, fd, stat, etag, req, res, end)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.st" id="apidoc.module.st">module st</a></h1>


    <h2>
        <a href="#apidoc.element.st.st" id="apidoc.element.st.st">
        function <span class="apidocSignatureSpan"></span>st
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function st(opt) {
  var p, u
  if (typeof opt === &#x27;string&#x27;) {
    p = opt
    opt = arguments[1]
    if (typeof opt === &#x27;string&#x27;) {
      u = opt
      opt = arguments[2]
    }
  }

  if (!opt) opt = {}
  else opt = util._extend({}, opt)

  if (!p) p = opt.path
  if (typeof p !== &#x27;string&#x27;) throw new Error(&#x27;no path specified&#x27;)
  p = path.resolve(p)
  if (!u) u = opt.url
  if (!u) u = &#x27;&#x27;
  if (u.charAt(0) !== &#x27;/&#x27;) u = &#x27;/&#x27; + u

  opt.url = u
  opt.path = p

  var m = new Mount(opt)
  var fn = m.serve.bind(m)
  fn._this = m
  return fn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount" id="apidoc.element.st.Mount">
        function <span class="apidocSignatureSpan">st.</span>Mount
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mount(opt) {
  if (!opt) throw new Error(&#x27;no options provided&#x27;)
  if (typeof opt !== &#x27;object&#x27;) throw new Error(&#x27;invalid options&#x27;)
  if (!(this instanceof Mount)) return new Mount(opt)

  this.opt = opt
  this.url = opt.url
  this.path = opt.path
  this._index = opt.index === false ? false
              : typeof opt.index === &#x27;string&#x27; ? opt.index
              : true
  this.fdman = FD()

  // cache basically everything
  var c = this.getCacheOptions(opt)
  this.cache = {
    fd: AC(c.fd),
    stat: AC(c.stat),
    index: AC(c.index),
    readdir: AC(c.readdir),
    content: AC(c.content)
  }

  this._cacheControl =
    c.content.maxAge === false
      ? undefined
      : typeof c.content.cacheControl == &#x27;string&#x27;
        ? c.content.cacheControl
        : opt.cache === false
          ? &#x27;no-cache&#x27;
          : &#x27;public, max-age=&#x27; + (c.content.maxAge / 1000)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.st.Mount" id="apidoc.module.st.Mount">module st.Mount</a></h1>


    <h2>
        <a href="#apidoc.element.st.Mount.Mount" id="apidoc.element.st.Mount.Mount">
        function <span class="apidocSignatureSpan">st.</span>Mount
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mount(opt) {
  if (!opt) throw new Error(&#x27;no options provided&#x27;)
  if (typeof opt !== &#x27;object&#x27;) throw new Error(&#x27;invalid options&#x27;)
  if (!(this instanceof Mount)) return new Mount(opt)

  this.opt = opt
  this.url = opt.url
  this.path = opt.path
  this._index = opt.index === false ? false
              : typeof opt.index === &#x27;string&#x27; ? opt.index
              : true
  this.fdman = FD()

  // cache basically everything
  var c = this.getCacheOptions(opt)
  this.cache = {
    fd: AC(c.fd),
    stat: AC(c.stat),
    index: AC(c.index),
    readdir: AC(c.readdir),
    content: AC(c.content)
  }

  this._cacheControl =
    c.content.maxAge === false
      ? undefined
      : typeof c.content.cacheControl == &#x27;string&#x27;
        ? c.content.cacheControl
        : opt.cache === false
          ? &#x27;no-cache&#x27;
          : &#x27;public, max-age=&#x27; + (c.content.maxAge / 1000)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.st.Mount.prototype" id="apidoc.module.st.Mount.prototype">module st.Mount.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.st.Mount.prototype._loadContent" id="apidoc.element.st.Mount.prototype._loadContent">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>_loadContent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadContent = function () {
  // this function should never be called.
  // we check if the thing is in the cache, and if not, stream it in
  // manually.  this.cache.content.get() should not ever happen.
  throw new Error(&#x27;This should not ever happen&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount.prototype._loadIndex" id="apidoc.element.st.Mount.prototype._loadIndex">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>_loadIndex
        <span class="apidocSignatureSpan">(p, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadIndex = function (p, cb) {
  // truncate off the first bits
  var url = p.substr(this.path.length).replace(/\\/g, &#x27;/&#x27;)
  var t = url
      .replace(/&#x22;/g, &#x27;&#x26;quot;&#x27;)
      .replace(/&#x3c;/g, &#x27;&#x26;lt;&#x27;)
      .replace(/&#x3e;/g, &#x27;&#x26;gt;&#x27;)
      .replace(/&#x27;/g, &#x27;&#x26;#39;&#x27;)

  var str =
    &#x27;&#x3c;!doctype html&#x3e;&#x27; +
    &#x27;&#x3c;html&#x3e;&#x27; +
    &#x27;&#x3c;head&#x3e;&#x3c;title&#x3e;Index of &#x27; + t + &#x27;&#x3c;/title&#x3e;&#x3c;/head&#x3e;&#x27; +
    &#x27;&#x3c;body&#x3e;&#x27; +
    &#x27;&#x3c;h1&#x3e;Index of &#x27; + t + &#x27;&#x3c;/h1&#x3e;&#x27; +
    &#x27;&#x3c;hr&#x3e;&#x3c;pre&#x3e;&#x3c;a href=&#x22;../&#x22;&#x3e;../&#x3c;/a&#x3e;\n&#x27;

  this.cache.readdir.get(p, function (er, data) {
    if (er) return cb(er)

    var nameLen = 0
    var sizeLen = 0

    Object.keys(data).map(function (f) {
      var d = data[f]

      var name = f
          .replace(/&#x22;/g, &#x27;&#x26;quot;&#x27;)
          .replace(/&#x3c;/g, &#x27;&#x26;lt;&#x27;)
          .replace(/&#x3e;/g, &#x27;&#x26;gt;&#x27;)
          .replace(/&#x27;/g, &#x27;&#x26;#39;&#x27;)

      if (d.size === &#x27;-&#x27;) name += &#x27;/&#x27;
      var showName = name.replace(/^(.{40}).{3,}$/, &#x27;$1..&#x3e;&#x27;)
      var linkName = encodeURIComponent(name)
                     .replace(/%2e/ig, &#x27;.&#x27;)     // Encoded dots are dots
                     .replace(/%2f|%5c/ig, &#x27;/&#x27;) // encoded slashes are /
                     .replace(/[\/\\]/g, &#x27;/&#x27;)   // back slashes are slashes

      nameLen = Math.max(nameLen, showName.length)
      sizeLen = Math.max(sizeLen, (&#x27;&#x27; + d.size).length)
      return [ &#x27;&#x3c;a href=&#x22;&#x27; + linkName + &#x27;&#x22;&#x3e;&#x27; + showName + &#x27;&#x3c;/a&#x3e;&#x27;,
               d.mtime, d.size, showName ]
    }).sort(function (a, b) {
      return a[2] === &#x27;-&#x27; &#x26;&#x26; b[2] !== &#x27;-&#x27; ? -1 // dirs first
           : a[2] !== &#x27;-&#x27; &#x26;&#x26; b[2] === &#x27;-&#x27; ? 1
           : a[0].toLowerCase() &#x3c; b[0].toLowerCase() ? -1 // then alpha
           : a[0].toLowerCase() &#x3e; b[0].toLowerCase() ? 1
           : 0
    }).forEach(function (line) {
      var namePad = new Array(8 + nameLen - line[3].length).join(&#x27; &#x27;)
      var sizePad = new Array(8 + sizeLen - (&#x27;&#x27; + line[2]).length).join(&#x27; &#x27;)
      str += line[0] + namePad +
             line[1].toISOString() +
             sizePad + line[2] + &#x27;\n&#x27;
    })

    str += &#x27;&#x3c;/pre&#x3e;&#x3c;hr&#x3e;&#x3c;/body&#x3e;&#x3c;/html&#x3e;&#x27;
    cb(null, new Buffer(str))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount.prototype._loadReaddir" id="apidoc.element.st.Mount.prototype._loadReaddir">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>_loadReaddir
        <span class="apidocSignatureSpan">(p, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadReaddir = function (p, cb) {
  var len
  var data
  fs.readdir(p, function (er, files) {
    if (er) return cb(er)
    files = files.filter(function (f) {
      if (!this.opt.dot) return !/^\./.test(f)
      else return f !== &#x27;.&#x27; &#x26;&#x26; f !== &#x27;..&#x27;
    }.bind(this))
    len = files.length
    data = {}
    files.forEach(function (file) {
      var pf = path.join(p, file)
      this.cache.stat.get(pf, function (er, stat) {
        if (er) return cb(er)
        if (stat.isDirectory()) stat.size = &#x27;-&#x27;
        data[file] = stat
        next()
      }.bind(this))
    }.bind(this))
  }.bind(this))

  function next () {
    if (--len === 0) cb(null, data)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount.prototype._loadStat" id="apidoc.element.st.Mount.prototype._loadStat">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>_loadStat
        <span class="apidocSignatureSpan">(key, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadStat = function (key, cb) {
  // key is either fd:path or just a path
  var fdp = key.match(/^(\d+):(.*)/)
  if (fdp) {
    var fd = +fdp[1]
    var p = fdp[2]
    fs.fstat(fd, function (er, stat) {
      if (er) return cb(er)
      this.cache.stat.set(p, stat)
      cb(null, stat)
    }.bind(this))
  } else {
    fs.stat(key, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount.prototype.autoindex" id="apidoc.element.st.Mount.prototype.autoindex">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>autoindex
        <span class="apidocSignatureSpan">(p, req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoindex = function (p, req, res) {
  if (!/\/$/.exec(req.sturl)) {
    res.statusCode = 301
    res.setHeader(&#x27;location&#x27;, req.sturl + &#x27;/&#x27;)
    res.end(&#x27;Moved: &#x27; + req.sturl + &#x27;/&#x27;)
    return
  }

  this.cache.index.get(p, function (er, html) {
    if (er) return this.error(er, res)

    res.statusCode = 200
    res.setHeader(&#x27;content-type&#x27;, &#x27;text/html&#x27;)
    res.setHeader(&#x27;content-length&#x27;, html.length)
    res.end(html)
  }.bind(this))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

res.setHeader(&#x27;content-type&#x27;, &#x27;text/plain&#x27;)
res.end(http.STATUS_CODES[res.statusCode] + &#x27;\n&#x27;)
}

Mount.prototype.index = function (p, req, res) {
if (this._index === true) {
  return this.<span class="apidocCodeKeywordSpan">autoindex</span>(p, req, res)
}
if (typeof this._index === &#x27;string&#x27;) {
  if (!/\/$/.test(req.sturl)) req.sturl += &#x27;/&#x27;
  req.sturl += this._index
  return this.serve(req, res)
}
return this.error(404, res)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount.prototype.cachedFile" id="apidoc.element.st.Mount.prototype.cachedFile">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>cachedFile
        <span class="apidocSignatureSpan">(p, stat, etag, req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cachedFile = function (p, stat, etag, req, res) {
  var key = stat.size + &#x27;:&#x27; + etag
  var gz = this.opt.gzip !== false &#x26;&#x26; getGz(p, req)

  this.cache.content.get(key, function (er, content) {
    if (er) return this.error(er, res)
    res.statusCode = 200
    if (this.opt.cachedHeader)
      res.setHeader(&#x27;x-from-cache&#x27;, &#x27;true&#x27;)
    if (gz &#x26;&#x26; content.gz) {
      res.setHeader(&#x27;content-encoding&#x27;, &#x27;gzip&#x27;)
      res.setHeader(&#x27;content-length&#x27;, content.gz.length)
      res.end(content.gz)
    } else {
      res.setHeader(&#x27;content-length&#x27;, content.length)
      res.end(content)
    }
  }.bind(this))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (mt !== &#x27;application/octet-stream&#x27;) {
  res.setHeader(&#x27;content-type&#x27;, mt)
}

// only use the content cache if it will actually fit there.
if (this.cache.content.has(key)) {
  end()
  this.<span class="apidocCodeKeywordSpan">cachedFile</span>(p, stat, etag, req, res)
} else {
  this.streamFile(p, fd, stat, etag, req, res, end)
}
}

Mount.prototype.cachedFile = function (p, stat, etag, req, res) {
var key = stat.size + &#x27;:&#x27; + etag
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount.prototype.error" id="apidoc.element.st.Mount.prototype.error">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>error
        <span class="apidocSignatureSpan">(er, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (er, res) {
  res.statusCode = typeof er === &#x27;number&#x27; ? er
                 : er.code === &#x27;ENOENT&#x27; || er.code === &#x27;EISDIR&#x27; ? 404
                 : er.code === &#x27;EPERM&#x27; || er.code === &#x27;EACCES&#x27; ? 403
                 : 500

  if (typeof res.error === &#x27;function&#x27;) {
    // pattern of express and ErrorPage
    return res.error(res.statusCode, er)
  }

  res.setHeader(&#x27;content-type&#x27;, &#x27;text/plain&#x27;)
  res.end(http.STATUS_CODES[res.statusCode] + &#x27;\n&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// inability to open is some kind of error, probably 404
// if we&#x27;re in passthrough, AND got a next function, we can
// fall through to that.  otherwise, we already returned true,
// send an error.
if (er) {
  if (this.opt.passthrough === true &#x26;&#x26; er.code === &#x27;ENOENT&#x27; &#x26;&#x26; next)
    return next()
  return this.<span class="apidocCodeKeywordSpan">error</span>(er, res)
}

// we may be about to use this, so don&#x27;t let it be closed by cache purge
this.fdman.checkout(p, fd)
// a safe end() function that can be called multiple times but
// only perform a single checkin
var end = this.fdman.checkinfn(p, fd)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount.prototype.file" id="apidoc.element.st.Mount.prototype.file">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>file
        <span class="apidocSignatureSpan">(p, fd, stat, etag, req, res, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file = function (p, fd, stat, etag, req, res, end) {
  var key = stat.size + &#x27;:&#x27; + etag

  var mt = mime.lookup(path.extname(p))
  if (mt !== &#x27;application/octet-stream&#x27;) {
    res.setHeader(&#x27;content-type&#x27;, mt)
  }

  // only use the content cache if it will actually fit there.
  if (this.cache.content.has(key)) {
    end()
    this.cachedFile(p, stat, etag, req, res)
  } else {
    this.streamFile(p, fd, stat, etag, req, res, end)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)
        res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,
          &#x27;Origin, X-Requested-With, Content-Type, Accept, Range&#x27;)
      }

      return isDirectory
        ? this.index(p, req, res)
        : this.<span class="apidocCodeKeywordSpan">file</span>(p, fd, stat, etag, req, res, end)
    }.bind(this))
  }.bind(this))

  return true
}

Mount.prototype.error = function (er, res) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount.prototype.getCacheOptions" id="apidoc.element.st.Mount.prototype.getCacheOptions">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>getCacheOptions
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCacheOptions = function (opt) {
  var o = opt.cache
    , set = function (key) {
        return o[key] === false
          ? util._extend({}, none)
          : util._extend(util._extend({}, d[key]), o[key])
      }

  if (o === false)
    o = noCaching
  else if (!o)
    o = {}

  var d = defaultCacheOptions

  // should really only ever set max and maxAge here.
  // load and fd disposal is important to control.
  var c = {
    fd: set(&#x27;fd&#x27;),
    stat: set(&#x27;stat&#x27;),
    index: set(&#x27;index&#x27;),
    readdir: set(&#x27;readdir&#x27;),
    content: set(&#x27;content&#x27;),
  }

  c.fd.dispose = this.fdman.close.bind(this.fdman)
  c.fd.load = this.fdman.open.bind(this.fdman)

  c.stat.load = this._loadStat.bind(this)
  c.index.load = this._loadIndex.bind(this)
  c.readdir.load = this._loadReaddir.bind(this)
  c.content.load = this._loadContent.bind(this)
  return c
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.path = opt.path
this._index = opt.index === false ? false
            : typeof opt.index === &#x27;string&#x27; ? opt.index
            : true
this.fdman = FD()

// cache basically everything
var c = this.<span class="apidocCodeKeywordSpan">getCacheOptions</span>(opt)
this.cache = {
  fd: AC(c.fd),
  stat: AC(c.stat),
  index: AC(c.index),
  readdir: AC(c.readdir),
  content: AC(c.content)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount.prototype.getPath" id="apidoc.element.st.Mount.prototype.getPath">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>getPath
        <span class="apidocSignatureSpan">(u)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPath = function (u) {
  var p = url.parse(u).pathname

  // Encoded dots are dots
  p = p.replace(/%2e/ig, &#x27;.&#x27;)

  // encoded slashes are /
  p = p.replace(/%2f|%5c/ig, &#x27;/&#x27;)

  // back slashes are slashes
  p = p.replace(/[\/\\]/g, &#x27;/&#x27;)

  // Make sure it starts with a slash
  p = p.replace(/^\//, &#x27;/&#x27;)

  if (p.match(/[\/\\]\.\.[\/\\]/)) {
    // traversal urls not ever even slightly allowed. clearly shenanigans
    // send a 403 on that noise, do not pass go, do not collect $200
    return 403
  }

  u = path.normalize(p).replace(/\\/g, &#x27;/&#x27;)
  if (u.indexOf(this.url) !== 0) return false

  try {
    u = decodeURIComponent(u)
  }
  catch (e) {
    // if decodeURIComponent failed, we weren&#x27;t given a valid URL to begin with.
    return false
  }

  // /a/b/c mounted on /path/to/z/d/x
  // /a/b/c/d --&#x3e; /path/to/z/d/x/d
  u = u.substr(this.url.length)
  if (u.charAt(0) !== &#x27;/&#x27;) u = &#x27;/&#x27; + u

  p = path.join(this.path, u)
  return p
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return false
}

// querystrings are of no concern to us
if (!req.sturl)
  req.sturl = url.parse(req.url).pathname

var p = this.<span class="apidocCodeKeywordSpan">getPath</span>(req.sturl)

// Falsey here means we got some kind of invalid path.
// Probably urlencoding we couldn&#x27;t understand, or some
// other &#x22;not compatible with st, but maybe ok&#x22; thing.
if (!p) {
  if (typeof next === &#x27;function&#x27;) next()
  return false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount.prototype.getUrl" id="apidoc.element.st.Mount.prototype.getUrl">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>getUrl
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUrl = function (p) {
  p = path.resolve(p)
  if (p.indexOf(this.path) !== 0) return false
  p = path.join(&#x27;/&#x27;, p.substr(this.path.length))
  var u = path.join(this.url, p).replace(/\\/g, &#x27;/&#x27;)
  return u
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount.prototype.index" id="apidoc.element.st.Mount.prototype.index">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>index
        <span class="apidocSignatureSpan">(p, req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">index = function (p, req, res) {
  if (this._index === true) {
    return this.autoindex(p, req, res)
  }
  if (typeof this._index === &#x27;string&#x27;) {
    if (!/\/$/.test(req.sturl)) req.sturl += &#x27;/&#x27;
    req.sturl += this._index
    return this.serve(req, res)
  }
  return this.error(404, res)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (this.opt.cors) {
        res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)
        res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,
          &#x27;Origin, X-Requested-With, Content-Type, Accept, Range&#x27;)
      }

      return isDirectory
        ? this.<span class="apidocCodeKeywordSpan">index</span>(p, req, res)
        : this.file(p, fd, stat, etag, req, res, end)
    }.bind(this))
  }.bind(this))

  return true
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount.prototype.serve" id="apidoc.element.st.Mount.prototype.serve">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>serve
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serve = function (req, res, next) {
  if (req.method !== &#x27;HEAD&#x27; &#x26;&#x26; req.method !== &#x27;GET&#x27;) {
    if (typeof next === &#x27;function&#x27;) next()
    return false
  }

  // querystrings are of no concern to us
  if (!req.sturl)
    req.sturl = url.parse(req.url).pathname

  var p = this.getPath(req.sturl)

  // Falsey here means we got some kind of invalid path.
  // Probably urlencoding we couldn&#x27;t understand, or some
  // other &#x22;not compatible with st, but maybe ok&#x22; thing.
  if (!p) {
    if (typeof next === &#x27;function&#x27;) next()
    return false
  }

  // don&#x27;t allow dot-urls by default, unless explicitly allowed.
  // If we got a 403, then it&#x27;s explicitly forbidden.
  if (p === 403 || !this.opt.dot &#x26;&#x26; req.sturl.match(/(^|\/)\./)) {
    res.statusCode = 403
    res.end(&#x27;Forbidden&#x27;)
    return true
  }

  // now we have a path.  check for the fd.
  this.cache.fd.get(p, function (er, fd) {
    // inability to open is some kind of error, probably 404
    // if we&#x27;re in passthrough, AND got a next function, we can
    // fall through to that.  otherwise, we already returned true,
    // send an error.
    if (er) {
      if (this.opt.passthrough === true &#x26;&#x26; er.code === &#x27;ENOENT&#x27; &#x26;&#x26; next)
        return next()
      return this.error(er, res)
    }

    // we may be about to use this, so don&#x27;t let it be closed by cache purge
    this.fdman.checkout(p, fd)
    // a safe end() function that can be called multiple times but
    // only perform a single checkin
    var end = this.fdman.checkinfn(p, fd)

    this.cache.stat.get(fd+&#x27;:&#x27;+p, function (er, stat) {
      if (er) {
        if (next &#x26;&#x26; this.opt.passthrough === true &#x26;&#x26; this._index === false) {
          return next()
        }
        end()
        return this.error(er, res)
      }

      var isDirectory = stat.isDirectory()

      if (isDirectory) {
        end() // we won&#x27;t need this fd for a directory in any case
        if (next &#x26;&#x26; this.opt.passthrough === true &#x26;&#x26; this._index === false) {
          // this is done before if-modified-since and if-non-match checks so
          // cached modified and etag values won&#x27;t return 304&#x27;s if we&#x27;ve since
          // switched to !index. See Issue #51.
          return next()
        }
      }

      var ims = req.headers[&#x27;if-modified-since&#x27;]
      if (ims) ims = new Date(ims).getTime()
      if (ims &#x26;&#x26; ims &#x3e;= stat.mtime.getTime()) {
        res.statusCode = 304
        res.end()
        return end()
      }

      var etag = getEtag(stat)
      if (req.headers[&#x27;if-none-match&#x27;] === etag) {
        res.statusCode = 304
        res.end()
        return end()
      }

      // only set headers once we&#x27;re sure we&#x27;ll be serving this request
      if (!res.getHeader(&#x27;cache-control&#x27;) &#x26;&#x26; this._cacheControl)
        res.setHeader(&#x27;cache-control&#x27;, this._cacheControl)
      res.setHeader(&#x27;last-modified&#x27;, stat.mtime.toUTCString())
      res.setHeader(&#x27;etag&#x27;, etag)

      if (this.opt.cors) {
        res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)
        res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,
          &#x27;Origin, X-Requested-With, Content-Type, Accept, Range&#x27;)
      }

      return isDirectory
        ? this.index(p, req, res)
        : this.file(p, fd, stat, etag, req, res, end)
    }.bind(this))
  }.bind(this))

  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Mount.prototype.index = function (p, req, res) {
if (this._index === true) {
  return this.autoindex(p, req, res)
}
if (typeof this._index === &#x27;string&#x27;) {
  if (!/\/$/.test(req.sturl)) req.sturl += &#x27;/&#x27;
  req.sturl += this._index
  return this.<span class="apidocCodeKeywordSpan">serve</span>(req, res)
}
return this.error(404, res)
}

Mount.prototype.autoindex = function (p, req, res) {
if (!/\/$/.exec(req.sturl)) {
  res.statusCode = 301
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.st.Mount.prototype.streamFile" id="apidoc.element.st.Mount.prototype.streamFile">
        function <span class="apidocSignatureSpan">st.Mount.prototype.</span>streamFile
        <span class="apidocSignatureSpan">(p, fd, stat, etag, req, res, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streamFile = function (p, fd, stat, etag, req, res, end) {
  var streamOpt = { fd: fd, start: 0, end: stat.size }
  var stream = fs.createReadStream(p, streamOpt)
  stream.destroy = function () {}

  // gzip only if not explicitly turned off or client doesn&#x27;t accept it
  var gzOpt = this.opt.gzip !== false
  var gz = gzOpt &#x26;&#x26; getGz(p, req)
  var cachable = this.cache.content._cache.max &#x3e; stat.size
  var gzstr

  // need a gzipped version for the cache, so do it regardless of what the client wants
  if (gz || (gzOpt &#x26;&#x26; cachable)) gzstr = zlib.Gzip()

  // too late to effectively handle any errors.
  // just kill the connection if that happens.
  stream.on(&#x27;error&#x27;, function(e) {
    console.error(&#x27;Error serving %s fd=%d\n%s&#x27;, p, fd, e.stack || e.message)
    res.socket.destroy()
    end()
  })

  if (res.filter) stream = stream.pipe(res.filter)

  res.statusCode = 200

  if (gz) {
    // we don&#x27;t know how long it&#x27;ll be, since it will be compressed.
    res.setHeader(&#x27;content-encoding&#x27;, &#x27;gzip&#x27;)
    stream.pipe(gzstr).pipe(res)
  } else {
    if (!res.filter) res.setHeader(&#x27;content-length&#x27;, stat.size)
    stream.pipe(res)
    if (gzstr)
      stream.pipe(gzstr) // for cache
  }

  stream.on(&#x27;end&#x27;, function () {
    process.nextTick(end)
  })

  if (cachable) {
    // collect it, and put it in the cache

    var calls = 0

    // called by bl() for both the raw stream and gzipped stream if we&#x27;re
    // caching gzipped data
    var collectEnd = function () {
      if (++calls == (gzOpt ? 2 : 1)) {
        var content = bufs.slice()
        content.gz = gzbufs &#x26;&#x26; gzbufs.slice()
        this.cache.content.set(key, content)
      }
    }.bind(this)

    var key = stat.size + &#x27;:&#x27; + etag
    var bufs = bl(collectEnd)
    var gzbufs

    stream.pipe(bufs)

    if (gzstr) {
      gzbufs = bl(collectEnd)
      gzstr.pipe(gzbufs)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// only use the content cache if it will actually fit there.
if (this.cache.content.has(key)) {
  end()
  this.cachedFile(p, stat, etag, req, res)
} else {
  this.<span class="apidocCodeKeywordSpan">streamFile</span>(p, fd, stat, etag, req, res, end)
}
}

Mount.prototype.cachedFile = function (p, stat, etag, req, res) {
var key = stat.size + &#x27;:&#x27; + etag
var gz = this.opt.gzip !== false &#x26;&#x26; getGz(p, req)
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
